import numpy as np
import json
from typing import Dict, Any

# 1. å¯¼å…¥é€šç”¨å·¥å…·
from utils_api import get_api_engine, get_unique_filename
from prompt.prompt_for_crypto import (
    get_action_and_response_format,
    get_navigation_hints,
    get_physics_rules,
    get_task_and_reward,
)
from obs.parse_crypto_obs import parse_crypto_obs

# 2. å¯¼å…¥ç¯å¢ƒ
try:
    from pettingzoo.mpe import simple_crypto_v3
except ImportError:
    raise ImportError("è¯·å®‰è£… pettingzoo: pip install pettingzoo[mpe]")

def get_header(env_name: str, agent_name: str, step: int) -> str:
    return (
        f"ENV: {env_name}\n"
        f"AGENT: {agent_name}\n"
        f"STEP: {step}"
    )


def _format_current_obs(obs_struct: Dict[str, Any]) -> str:
    role = obs_struct.get("role", "UNKNOWN")
    data_flow = [
        "CURRENT DATA FLOW:",
        f"- role: {role}",
        f"- raw: {obs_struct.get('raw')}",
    ]
    if role == "ALICE":
        data_flow.append(f"- message (M): {obs_struct.get('message')}")
        data_flow.append(f"- key (K): {obs_struct.get('key')}")
    elif role == "BOB":
        data_flow.append(f"- key (K): {obs_struct.get('key')}")
        data_flow.append(f"- ciphertext (C): {obs_struct.get('ciphertext')}")
    elif role == "EVE":
        data_flow.append(f"- ciphertext (C): {obs_struct.get('ciphertext')}")
    return "\n".join(data_flow)


def user_prompt_crypto(agent_id: str, step: int, obs_struct: Dict[str, Any]) -> str:
    role = obs_struct.get("role", "UNKNOWN")
    parts = [
        get_header("Simple_Crypto_v3", agent_id, step),
        get_task_and_reward(role),
        get_physics_rules(),
        get_action_and_response_format(),
        get_navigation_hints(role),
        _format_current_obs(obs_struct),
    ]
    return "\n\n".join(parts)


# ============================================================================== 
# 3. ä¸»å¾ªç¯
# ==============================================================================
def run_crypto_game(provider: str, output_name: str, **kwargs):
    # MPE Crypto æ¯ä¸€å¸§çš„æ•°æ®é€šå¸¸æ˜¯ç‹¬ç«‹çš„ï¼ˆæˆ–è€…è¯´ç¯å¢ƒä¸ä¼šè®°å¿†ä¸Šä¸€å¸§çš„åŠ å¯†ï¼‰ï¼Œ
    # çœŸæ­£çš„å­¦ä¹ éœ€è¦å¤šè½®è¿­ä»£ã€‚ä½†åœ¨ zero-shot è®¾å®šä¸‹ï¼Œæˆ‘ä»¬çœ‹æ¨¡å‹å•æ¬¡çš„æ¨ç†èƒ½åŠ›ã€‚
    MAX_STEPS = 10
    
    seed = kwargs.pop('seed', None)
    llm_engine = get_api_engine(provider, **kwargs)

    print("Initializing Crypto Env (Fair Mode)...")
    env = simple_crypto_v3.parallel_env(max_cycles=MAX_STEPS, continuous_actions=True, render_mode="rgb_array")
    
    observations, infos = env.reset(seed=seed) if seed is not None else env.reset()
    frames = []
    game_log = []
    
    for step in range(MAX_STEPS):
        print(f"\n{'='*40} STEP {step} {'='*40}")
        
        frame = env.render()
        if frame is not None:
            frames.append(frame)
        
        actions = {}
        step_buffer = {} # æš‚å­˜æœ¬å›åˆä¿¡æ¯

        # --- 1. Decision Phase ---
        for agent_id in env.agents:
            obs_raw = observations[agent_id]
            obs_struct = parse_crypto_obs(obs_raw, agent_id)
            
            # Prompt
            full_prompt = user_prompt_crypto(agent_id, step, obs_struct)
            
            # System Role
            if 'alice' in agent_id: sys_r = "You are Alice, a Cryptographer."
            elif 'bob' in agent_id: sys_r = "You are Bob, a Cryptographer."
            else: sys_r = "You are Eve, a Code Breaker."
            
            # API Call
            action_vec, raw_thought = llm_engine.generate_action(sys_r, full_prompt)
            
            # ç»´åº¦ä¿®æ­£ & Clip
            if len(action_vec) < 4:
                action_vec = np.concatenate([action_vec, np.zeros(4 - len(action_vec))])
            elif len(action_vec) > 4:
                action_vec = action_vec[:4]
            action_vec = np.clip(action_vec, 0.0, 1.0)
            
            actions[agent_id] = action_vec
            
            step_buffer[agent_id] = {
                "struct": obs_struct,
                "action": action_vec,
                "thought": raw_thought
            }

        # --- 2. Step Phase ---
        observations, rewards, terminations, truncations, infos = env.step(actions)
        
        # --- 3. Analysis Phase ---
        # è·å–çœŸå€¼ (Ground Truth)
        true_msg = step_buffer['alice_0']['struct']['message']
        
        for aid, info in step_buffer.items():
            r = rewards.get(aid, 0.0)
            role = info['struct']['role']
            print(f"\nğŸ‘¤ {aid} ({role}) | Reward: {r:.3f}")
            
            # æ‰“å°é€»è¾‘é“¾
            if role == 'ALICE':
                msg = np.array(info['struct']['message'])
                key = np.array(info['struct']['key'])
                cip = np.array(info['action'])
                print(f"   [Logic] Msg {np.round(msg,2)} + Key {np.round(key,2)} -> Cipher {np.round(cip,2)}")
                
            elif role == 'BOB':
                key = np.array(info['struct']['key'])
                cip = np.array(info['struct']['ciphertext']) # è¿™æ˜¯ä¸Šä¸€å›åˆçš„ï¼Œæˆ–è€…æœ¬å›åˆè¿˜æ²¡æ”¶åˆ°ï¼Ÿ
                # MPE æœºåˆ¶æé†’ï¼šBob è¿™ä¸€æ­¥çœ‹åˆ°çš„ Ciphertext å…¶å®æ˜¯ Alice *ä¸Šä¸€æ­¥* å‘çš„ã€‚
                # åœ¨ Step 0ï¼ŒBob çœ‹åˆ°çš„ Ciphertext é€šå¸¸æ˜¯ 0ã€‚
                # æ‰€ä»¥ Bob çš„æ¨ç†å…¶å®æ˜¯æ»åä¸€æ­¥çš„ã€‚ä½†ä¸ºäº†è¯„æµ‹ LLM å•æ­¥èƒ½åŠ›ï¼Œæˆ‘ä»¬çœ‹å®ƒæ˜¯å¦å°è¯•å»ç®—ã€‚
                guess = np.array(info['action'])
                print(f"   [Logic] Key {np.round(key,2)} + Cipher {np.round(cip,2)} -> Guess {np.round(guess,2)}")
                
                # è®¡ç®—å½“å‰å¸§è¯¯å·® (è™½ç„¶ç¯å¢ƒå¯èƒ½æ˜¯æ»åç»“ç®—ï¼Œæˆ‘ä»¬è‚‰çœ¼çœ‹å½“ä¸‹çš„åŒ¹é…åº¦)
                # æ³¨æ„ï¼šBob æœ¬å›åˆçš„çŒœæµ‹åº”è¯¥å¯¹åº” Alice æœ¬å›åˆçš„å‘é€å—ï¼Ÿ
                # ä¸ï¼ŒMPE æ˜¯ Alice å‘ -> Env å­˜ -> ä¸‹ä¸€æ­¥ Bob æ”¶ã€‚
                # æ‰€ä»¥ Step 0 Bob çŒœä¸å¯¹æ˜¯æ­£å¸¸çš„ã€‚æˆ‘ä»¬è¦çœ‹ Step 1ã€‚
                
            elif role == 'EVE':
                cip = np.array(info['struct']['ciphertext'])
                guess = np.array(info['action'])
                print(f"   [Logic] Cipher {np.round(cip,2)} -> Guess {np.round(guess,2)}")

            # æ‰“å°æ€ç»´é“¾æ‘˜è¦
            print(f"   ğŸ§  Thought: {info['thought'][:200].replace(chr(10), ' ')}...")
            
            game_log.append({
                "step": step,
                "agent": aid,
                "reward": r,
                "obs": info['struct'],
                "action": info['action'].tolist(),
                "thought": info['thought']
            })

        if all(terminations.values()) or all(truncations.values()):
            print("Game Over.")
            break

    env.close()
    
    # Calculate final summary
    total_rewards = {}
    for entry in game_log:
        if "agent" in entry:
            aid = entry["agent"]
            total_rewards[aid] = total_rewards.get(aid, 0.0) + entry.get("reward", 0.0)
    
    mean_reward = sum(total_rewards.values()) / len(total_rewards) if total_rewards else 0.0
    game_log.append({
        "final_summary": True,
        "total_rewards": total_rewards,
        "mean_reward": float(mean_reward)
    })
    print(f"\nğŸ“Š FINAL: Total Rewards={total_rewards}, Mean={mean_reward:.3f}")
    
    # Save video
    if frames:
        vid_name = get_unique_filename(output_name + ".mp4")
        import imageio
        imageio.mimsave(vid_name, frames, fps=1, macro_block_size=1)
        print(f"Saved video to {vid_name}")
    
    final_log = get_unique_filename(output_name + ".json")
    with open(final_log, "w", encoding="utf-8") as f:
        json.dump(game_log, f, indent=4)
    print(f"Saved logs to {final_log}")

# ============================================================================== 
# 4. å…¥å£
# ==============================================================================
if __name__ == "__main__":
    # ========== ç»Ÿä¸€æ¨¡å‹æ¥å£ ==========
    # è¿œç¨‹ API: 'deepseek', 'qwen', 'gpt', 'gemini'
    # æœ¬åœ°æ¨¡å‹: 'transformers', 'ollama', 'vllm'
    
    # æ–¹å¼ 1: ä½¿ç”¨é»˜è®¤é…ç½®
    PROVIDER = "qwen"
    
    # æ–¹å¼ 2: è‡ªå®šä¹‰ API Key
    # PROVIDER = "deepseek"
    # run_crypto_game(PROVIDER, "crypto_demo", api_key="your-key")
    
    # æ–¹å¼ 3: ä½¿ç”¨æœ¬åœ° Ollama æ¨¡å‹
    # PROVIDER = "ollama"
    # run_crypto_game(PROVIDER, "crypto_demo", model_name="qwen2.5:7b")
    
    # æ–¹å¼ 4: ä½¿ç”¨ Transformers æœ¬åœ°æ¨¡å‹
    # PROVIDER = "transformers"
    # run_crypto_game(PROVIDER, "crypto_demo", model_path="Qwen/Qwen2.5-7B-Instruct", device="cuda")

    print("Starting Crypto Fair Evaluation...")
    run_crypto_game(PROVIDER, "crypto_fair_run")